import{_ as e,c as a,e as s,a as t,b as n,d as r,r as i,o as g}from"./app-BSRiWrsC.js";const l={},d={href:"https://www.zybuluo.com/hanbingtao/note/448086",target:"_blank",rel:"noopener noreferrer"},m={href:"https://www.zybuluo.com/hanbingtao/note/476663#an1",target:"_blank",rel:"noopener noreferrer"},u={href:"https://www.zybuluo.com/hanbingtao/note/448086",target:"_blank",rel:"noopener noreferrer"};function h(b,p){const o=i("ExternalLinkIcon");return g(),a("div",null,[p[14]||(p[14]=s('<h3 id="往期回顾" tabindex="-1"><a class="header-anchor" href="#往期回顾"><span>往期回顾</span></a></h3><p>在上一篇文章中，我们已经掌握了机器学习的基本套路，对模型、目标函数、优化算法这些概念有了一定程度的理解，而且已经会训练单个的感知器或者线性单元了。在这篇文章中，我们将把这些单独的单元按照一定的规则相互连接在一起形成<strong>神经网络</strong>，从而奇迹般的获得了强大的学习能力。我们还将介绍这种网络的训练算法：<strong>反向传播算法</strong>。最后，我们依然用代码实现一个神经网络。如果您能坚持到本文的结尾，将会看到我们用自己实现的神经网络去识别手写数字。现在请做好准备，您即将双手触及到深度学习的大门。</p><h3 id="神经元" tabindex="-1"><a class="header-anchor" href="#神经元"><span>神经元</span></a></h3><p>神经元和感知器本质上是一样的，只不过我们说感知器的时候，它的激活函数是<strong>阶跃函数</strong>；而当我们说神经元时，激活函数往往选择为sigmoid函数或tanh函数。如下图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/2256672-49f06e2e9d3eb29f.gif" alt="img"></p><p>计算一个神经元的输出的方法和计算一个感知器的输出是一样的。假设神经元的输入是向量，权重向量是(偏置项是)，激活函数是sigmoid函数，则其输出：</p><p>式</p><p>sigmoid函数的定义如下：</p><p>将其带入前面的式子，得到</p><p>sigmoid函数是一个非线性函数，值域是(0,1)。函数图像如下图所示</p><p><img src="http://upload-images.jianshu.io/upload_images/2256672-e7e64f57dc6b1c64.jpg" alt="img"></p><p>sigmoid函数的导数是：</p><p>令则</p><p>可以看到，sigmoid函数的导数非常有趣，它可以用sigmoid函数自身来表示。这样，一旦计算出sigmoid函数的值，计算它的导数的值就非常方便。</p><h3 id="神经网络是啥" tabindex="-1"><a class="header-anchor" href="#神经网络是啥"><span>神经网络是啥</span></a></h3><p><img src="http://upload-images.jianshu.io/upload_images/2256672-92111b104ce0d571.jpeg" alt="img"></p><p>神经网络其实就是按照<strong>一定规则</strong>连接起来的多个<strong>神经元</strong>。上图展示了一个**全连接(full connected, FC)**神经网络，通过观察上面的图，我们可以发现它的规则包括：</p><ul><li>神经元按照<strong>层</strong>来布局。最左边的层叫做<strong>输入层</strong>，负责接收输入数据；最右边的层叫<strong>输出层</strong>，我们可以从这层获取神经网络输出数据。输入层和输出层之间的层叫做<strong>隐藏层</strong>，因为它们对于外部来说是不可见的。</li><li>同一层的神经元之间没有连接。</li><li>第N层的每个神经元和第N-1层的<strong>所有</strong>神经元相连(这就是full connected的含义)，第N-1层神经元的输出就是第N层神经元的输入。</li><li>每个连接都有一个<strong>权值</strong>。</li></ul><p>上面这些规则定义了全连接神经网络的结构。事实上还存在很多其它结构的神经网络，比如卷积神经网络(CNN)、循环神经网络(RNN)，他们都具有不同的连接规则。</p><h3 id="计算神经网络的输出" tabindex="-1"><a class="header-anchor" href="#计算神经网络的输出"><span>计算神经网络的输出</span></a></h3><p>神经网络实际上就是一个输入向量到输出向量的函数，即：</p><p>根据输入计算神经网络的输出，需要首先将输入向量的每个元素的值赋给神经网络的输入层的对应神经元，然后根据<strong>式1</strong>依次向前计算每一层的每个神经元的值，直到最后一层输出层的所有神经元的值计算完毕。最后，将输出层每个神经元的值串在一起就得到了输出向量。</p><p>接下来举一个例子来说明这个过程，我们先给神经网络的每个单元写上编号。</p><p><img src="http://upload-images.jianshu.io/upload_images/2256672-bfbb364740f898d1.png" alt="img"></p><p>如上图，输入层有三个节点，我们将其依次编号为1、2、3；隐藏层的4个节点，编号依次为4、5、6、7；最后输出层的两个节点编号为8、9。因为我们这个神经网络是<strong>全连接</strong>网络，所以可以看到每个节点都和<strong>上一层的所有节点</strong>有连接。比如，我们可以看到隐藏层的节点4，它和输入层的三个节点1、2、3之间都有连接，其连接上的权重分别为。那么，我们怎样计算节点4的输出值呢？</p><p>为了计算节点4的输出值，我们必须先得到其所有上游节点（也就是节点1、2、3）的输出值。节点1、2、3是<strong>输入层</strong>的节点，所以，他们的输出值就是输入向量本身。按照上图画出的对应关系，可以看到节点1、2、3的输出值分别是。我们要求<strong>输入向量的维度和输入层神经元个数相同</strong>，而输入向量的某个元素对应到哪个输入节点是可以自由决定的，你偏非要把赋值给节点2也是完全没有问题的，但这样除了把自己弄晕之外，并没有什么价值。</p><p>一旦我们有了节点1、2、3的输出值，我们就可以根据<strong>式1</strong>计算节点4的输出值：</p><p>上式的是节点4的<strong>偏置项</strong>，图中没有画出来。而分别为节点1、2、3到节点4连接的权重，在给权重编号时，我们把目标节点的编号放在前面，把源节点的编号放在后面。</p><p>同样，我们可以继续计算出节点5、6、7的输出值。这样，隐藏层的4个节点的输出值就计算完成了，我们就可以接着计算输出层的节点8的输出值：</p><p>同理，我们还可以计算出的值。这样输出层所有节点的输出值计算完毕，我们就得到了在输入向量时，神经网络的输出向量。这里我们也看到，<strong>输出向量的维度和输出层神经元个数相同</strong>。</p><h4 id="神经网络的矩阵表示" tabindex="-1"><a class="header-anchor" href="#神经网络的矩阵表示"><span>神经网络的矩阵表示</span></a></h4><p>神经网络的计算如果用矩阵来表示会很方便（当然逼格也更高），我们先来看看隐藏层的矩阵表示。</p><p>首先我们把隐藏层4个节点的计算依次排列出来：</p><p>接着，定义网络的输入向量和隐藏层每个节点的权重向量。令</p><p>代入到前面的一组式子，得到：</p><p>现在，我们把上述计算的四个式子写到一个矩阵里面，每个式子作为矩阵的一行，就可以利用矩阵来表示它们的计算了。令</p><p>带入前面的一组式子，得到</p><p>式</p><p>在<strong>式2</strong>中，是激活函数，在本例中是函数；是某一层的权重矩阵；是某层的输入向量；是某层的输出向量。<strong>式2</strong>说明神经网络的每一层的作用实际上就是先将输入向量<strong>左乘</strong>一个数组进行线性变换，得到一个新的向量，然后再对这个向量<strong>逐元素</strong>应用一个激活函数。</p><p>每一层的算法都是一样的。比如，对于包含一个输入层，一个输出层和三个隐藏层的神经网络，我们假设其权重矩阵分别为，每个隐藏层的输出分别是，神经网络的输入为，神经网络的输入为，如下图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/2256672-c1388dc8fdcce427.png" alt="img"></p><p>则每一层的输出向量的计算可以表示为：</p><p>这就是神经网络输出值的计算方法。</p><h3 id="神经网络的训练" tabindex="-1"><a class="header-anchor" href="#神经网络的训练"><span>神经网络的训练</span></a></h3><p>现在，我们需要知道一个神经网络的每个连接上的权值是如何得到的。我们可以说神经网络是一个<strong>模型</strong>，那么这些权值就是模型的<strong>参数</strong>，也就是模型要学习的东西。然而，一个神经网络的连接方式、网络的层数、每层的节点数这些参数，则不是学习出来的，而是人为事先设置的。对于这些人为设置的参数，我们称之为<strong>超参数(Hyper-Parameters)</strong>。</p><p>接下来，我们将要介绍神经网络的训练算法：反向传播算法。</p><h4 id="反向传播算法-back-propagation" tabindex="-1"><a class="header-anchor" href="#反向传播算法-back-propagation"><span>反向传播算法(Back Propagation)</span></a></h4><p>我们首先直观的介绍反向传播算法，最后再来介绍这个算法的推导。当然读者也可以完全跳过推导部分，因为即使不知道如何推导，也不影响你写出来一个神经网络的训练代码。事实上，现在神经网络成熟的开源实现多如牛毛，除了练手之外，你可能都没有机会需要去写一个神经网络。</p>',48)),t("p",null,[p[2]||(p[2]=n("我们以")),p[3]||(p[3]=t("strong",null,"监督学习",-1)),p[4]||(p[4]=n("为例来解释反向传播算法。在")),t("a",d,[p[0]||(p[0]=n("零基础入门深度学习(2) - 线性单元和梯度下降")),r(o)]),p[5]||(p[5]=n("一文中我们介绍了什么是")),p[6]||(p[6]=t("strong",null,"监督学习",-1)),p[7]||(p[7]=n("，如果忘记了可以再看一下。另外，我们设神经元的激活函数为函数(不同激活函数的计算公式不同，详情见")),t("a",m,[p[1]||(p[1]=n("反向传播算法的推导")),r(o)]),p[8]||(p[8]=n("一节)。"))]),p[15]||(p[15]=s('<p>我们假设每个训练样本为，其中向量是训练样本的特征，而是样本的目标值。</p><p><img src="http://upload-images.jianshu.io/upload_images/2256672-6f27ced45cf5c0d8.png" alt="img"></p><p>首先，我们根据上一节介绍的算法，用样本的特征，计算出神经网络中每个隐藏层节点的输出，以及输出层每个节点的输出。</p><p>然后，我们按照下面的方法计算出每个节点的误差项：</p><ul><li>对于输出层节点，</li></ul><p>式</p><p>其中，是节点的误差项，是节点的<strong>输出值</strong>，是样本对应于节点的<strong>目标值</strong>。举个例子，根据上图，对于输出层节点8来说，它的输出值是，而样本的目标值是，带入上面的公式得到节点8的误差项应该是：</p><ul><li>对于隐藏层节点，</li></ul><p>式</p><p>其中，是节点的输出值，是节点到它的下一层节点的连接的权重，是节点的下一层节点的误差项。例如，对于隐藏层节点4来说，计算方法如下：</p><p>最后，更新每个连接上的权值：</p><p>式</p><p>其中，是节点到节点的权重，是一个成为<strong>学习速率</strong>的常数，是节点的误差项，是节点传递给节点的输入。例如，权重的更新方法如下：</p><p>类似的，权重的更新方法如下：</p><p>偏置项的输入值永远为1。例如，节点4的偏置项应该按照下面的方法计算：</p><p>我们已经介绍了神经网络每个节点误差项的计算和权重更新方法。显然，计算一个节点的误差项，需要先计算每个与其相连的下一层节点的误差项。这就要求误差项的计算顺序必须是从输出层开始，然后反向依次计算每个隐藏层的误差项，直到与输入层相连的那个隐藏层。这就是反向传播算法的名字的含义。当所有节点的误差项计算完毕后，我们就可以根据<strong>式5</strong>来更新所有的权重。</p><p>以上就是基本的反向传播算法，并不是很复杂，您弄清楚了么？</p><h4 id="反向传播算法的推导" tabindex="-1"><a class="header-anchor" href="#反向传播算法的推导"><span>反向传播算法的推导</span></a></h4><p>反向传播算法其实就是链式求导法则的应用。然而，这个如此简单且显而易见的方法，却是在Roseblatt提出感知器算法将近30年之后才被发明和普及的。对此，Bengio这样回应道：</p><blockquote><p>很多看似显而易见的想法只有在事后才变得显而易见。</p></blockquote><p>接下来，我们用链式求导法则来推导反向传播算法，也就是上一小节的<strong>式3</strong>、<strong>式4</strong>、<strong>式5</strong>。</p><p>*<strong>前方高能预警——接下来是数学公式重灾区，读者可以酌情阅读，不必强求。*</strong></p><p>按照机器学习的通用套路，我们先确定神经网络的目标函数，然后用<strong>随机梯度下降</strong>优化算法去求目标函数最小值时的参数值。</p><p>我们取网络所有输出层节点的误差平方和作为目标函数：</p><p>其中，表示是样本的误差。</p>',25)),t("p",null,[p[10]||(p[10]=n("然后，我们用文章")),t("a",u,[p[9]||(p[9]=n("零基础入门深度学习(2) - 线性单元和梯度下降")),r(o)]),p[11]||(p[11]=n("中介绍的")),p[12]||(p[12]=t("strong",null,"随机梯度下降",-1)),p[13]||(p[13]=n("算法对目标函数进行优化："))]),p[16]||(p[16]=s('<p>随机梯度下降算法也就是需要求出误差对于每个权重的偏导数（也就是梯度），怎么求呢？</p><p><img src="http://upload-images.jianshu.io/upload_images/2256672-6f27ced45cf5c0d8.png" alt="img"></p><p>观察上图，我们发现权重仅能通过影响节点的输入值影响网络的其它部分，设是节点的<strong>加权输入</strong>，即</p><p>是的函数，而是的函数。根据链式求导法则，可以得到：</p><p>上式中，是节点传递给节点的输入值，也就是节点的输出值。</p><p>对于的推导，需要区分<strong>输出层</strong>和<strong>隐藏层</strong>两种情况。</p><h5 id="输出层权值训练" tabindex="-1"><a class="header-anchor" href="#输出层权值训练"><span>输出层权值训练</span></a></h5><p>对于<strong>输出层</strong>来说，仅能通过节点的输出值来影响网络其它部分，也就是说是的函数，而是的函数，其中。所以我们可以再次使用链式求导法则：</p><p>考虑上式第一项:</p><p>考虑上式第二项：</p><p>将第一项和第二项带入，得到：</p><p>如果令，也就是一个节点的误差项是网络误差对这个节点输入的偏导数的相反数。带入上式，得到：</p><p>上式就是<strong>式3</strong>。</p><p>将上述推导带入随机梯度下降公式，得到：</p><p>上式就是<strong>式5</strong>。</p><h5 id="隐藏层权值训练" tabindex="-1"><a class="header-anchor" href="#隐藏层权值训练"><span>隐藏层权值训练</span></a></h5><p>现在我们要推导出隐藏层的。</p><p>首先，我们需要定义节点的所有直接下游节点的集合。例如，对于节点4来说，它的直接下游节点是节点8、节点9。可以看到只能通过影响再影响。设是节点的下游节点的输入，则是的函数，而是的函数。因为有多个，我们应用全导数公式，可以做出如下推导：</p><p>因为，带入上式得到：</p><p>上式就是<strong>式4</strong>。</p><p>*<strong>——数学公式警报解除——*</strong></p><p>至此，我们已经推导出了反向传播算法。需要注意的是，我们刚刚推导出的训练规则是根据激活函数是sigmoid函数、平方和误差、全连接网络、随机梯度下降优化算法。如果激活函数不同、误差计算方式不同、网络连接结构不同、优化算法不同，则具体的训练规则也会不一样。但是无论怎样，训练规则的推导方式都是一样的，应用链式求导法则进行推导即可。</p><h3 id="神经网络的实现" tabindex="-1"><a class="header-anchor" href="#神经网络的实现"><span>神经网络的实现</span></a></h3><blockquote><p>完整代码请参考GitHub: https://github.com/hanbt/learn_dl/blob/master/bp.py (python2.7)</p></blockquote><p>现在，我们要根据前面的算法，实现一个基本的全连接神经网络，这并不需要太多代码。我们在这里依然采用面向对象设计。</p><p>首先，我们先做一个基本的模型：</p><p><img src="http://upload-images.jianshu.io/upload_images/2256672-2fbae2ee722fbef9.png?imageMogr2/auto-orient/strip|imageView2/2/w/360" alt="img"></p><p>如上图，可以分解出5个领域对象来实现神经网络：</p><ul><li><em>Network</em> 神经网络对象，提供API接口。它由若干层对象组成以及连接对象组成。</li><li><em>Layer</em> 层对象，由多个节点组成。</li><li><em>Node</em> 节点对象计算和记录节点自身的信息(比如输出值、误差项等)，以及与这个节点相关的上下游的连接。</li><li><em>Connection</em> 每个连接对象都要记录该连接的权重。</li><li><em>Connections</em> 仅仅作为Connection的集合对象，提供一些集合操作。</li></ul>',29))])}const c=e(l,[["render",h]]),k=JSON.parse('{"path":"/blogs/Miscellaneous/AI_Preliminary.html","title":"深度学习入门","lang":"en-US","frontmatter":{"title":"深度学习入门","date":"2024-09-01T00:00:00.000Z","tags":["Learning"],"categories":["Miscellaneous"]},"headers":[{"level":3,"title":"往期回顾","slug":"往期回顾","link":"#往期回顾","children":[]},{"level":3,"title":"神经元","slug":"神经元","link":"#神经元","children":[]},{"level":3,"title":"神经网络是啥","slug":"神经网络是啥","link":"#神经网络是啥","children":[]},{"level":3,"title":"计算神经网络的输出","slug":"计算神经网络的输出","link":"#计算神经网络的输出","children":[]},{"level":3,"title":"神经网络的训练","slug":"神经网络的训练","link":"#神经网络的训练","children":[]},{"level":3,"title":"神经网络的实现","slug":"神经网络的实现","link":"#神经网络的实现","children":[]}],"git":{"createdTime":1744420073000,"updatedTime":1744420073000,"contributors":[{"name":"NewLearner4396","email":"NewLearner4396@users.noreply.github.com","commits":1}]},"filePathRelative":"blogs/Miscellaneous/AI_Preliminary.md"}');export{c as comp,k as data};
